.pio_version 0 // only requires PIO version 0

; Patterns when testing
;.define TX_HIGH 0b10
;.define TX_LOW  0b01
;.define TX_IDLE 0b00

; Actual patterns when using a driver
.define PUBLIC TX_HIGH 0b11
.define PUBLIC TX_LOW  0b01
.define PUBLIC TX_IDLE 0b00

; length of half-bit pulses (multipled by 6.7ns)

.define PUBLIC CS_PULSE_LEN_A   30
.define PUBLIC CS_PULSE_LEN_B   14
.define DATA_PULSE_LEN   15

; the reply sampling points (multiplied by 6.7ns)

.define SAMPLE_POS_1  10   ; 5 - 16 works
.define SAMPLE_POS_2  25

; how long to wait for the reply (multiplied by 20ns)




.program isospi_master
.side_set 1
.wrap_target

do_bit:

    ; read a bit
    out x, 1 side 0

    jmp !x zero_bit side 0

    ; output a 1
  PUBLIC data_high_1:
    set pins, TX_HIGH side 0 [DATA_PULSE_LEN-1]
  PUBLIC data_low_1:
    set pins, TX_LOW side 0 [DATA_PULSE_LEN-1]
    jmp done side 0

    ; cheeky void space

zero_bit:
    ; output a 0
  PUBLIC data_low_2:
    set pins, TX_LOW side 0 [DATA_PULSE_LEN-1]
  PUBLIC data_high_2:
    set pins, TX_HIGH side 0 [DATA_PULSE_LEN-1]

done:
    ; go idle and wait for the lines to settle
  PUBLIC pre_rx:
    set pins, TX_IDLE side 0 [10] ; min 10?, too long and we miss the reply
    ; at 300mhz, 6 - 14 works

    ; start the timer
    irq set 1 side 0

    ; clear any pending irq
    irq clear 0 side 0

    ; wake up the wait-for-highers
    irq clear 3 side 0

    ; wait for a bit to start
  PUBLIC sample_1:
    wait 1 irq 0 side 0 [SAMPLE_POS_1 - 1]

    ; first sample (also store it in x for later)
    mov x, pins side 1
  PUBLIC sample_2:
    in x, 2 side 1 [SAMPLE_POS_2 - SAMPLE_POS_1 - 2]

    ; second sample (also store it in y for later)
    mov y, pins side 0
    in y, 2 side 0

    ; wait for the timer to finish
    ;wait 1 irq 2 [3]
    irq wait 2 side 0 [3]
.wrap


.program isospi_master_cs
.wrap_target

    out x, 2
    out y, 2

    ; do the chip select pattern
  ;PUBLIC cs_high_1:
    mov pins x  [CS_PULSE_LEN_A-1]
    mov pins x  [CS_PULSE_LEN_B-1]
  ;PUBLIC cs_low_1:
    mov pins y  [CS_PULSE_LEN_A-1]
    mov pins y  [CS_PULSE_LEN_B-1]
    set pins TX_IDLE [31]
.wrap


.program isospi_master_exec
.wrap_target
    out exec, 16
.wrap


.program isospi_master_wait_for_high
.wrap_target
    ; wait to be woken up (irq 3 gets cleared)
    irq wait 3

    wait 1 pin 0
    irq set 0  [20] ; [3]
    wait 0 pin 0; [12]
.wrap


.program isospi_master_wait_for_low
.wrap_target
    ; wait to be woken up (irq 3 gets cleared)
    irq wait 3

    wait 0 pin 0
    irq set 0  ; [3]
    wait 1 pin 0
.wrap


.program isospi_master_wait_for_gap
.wrap_target
    ; wait to be woken up
    wait 1 irq 1 [31]
    ; after a while, trigger the receiver

    ; at 300mhz with isodevice, the nop needs to come first
    nop [31]
    irq set 0 [31]

    ; then trigger the next send
    irq clear 2
.wrap


% c-sdk {
// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin

PIO master_pio;
uint32_t master_offset;
pio_sm_config master_config;
uint32_t cs_program_offset;
pio_sm_config cs_program_config;

void isospi_master_program_init(PIO pio, uint tx_pin_base, uint rx_pin_base) {
    // Outputs
    pio_gpio_init(pio, tx_pin_base);
    pio_gpio_init(pio, tx_pin_base + 1);

    // Inputs (we don't need the pio to own these)
    gpio_init(rx_pin_base);
    gpio_set_dir(rx_pin_base, GPIO_IN);
    gpio_pull_up(rx_pin_base);

    gpio_init(rx_pin_base + 1);
    gpio_set_dir(rx_pin_base + 1, GPIO_IN);
    gpio_pull_up(rx_pin_base + 1);

    // invert both RX pins
    gpio_set_inover(rx_pin_base, GPIO_OVERRIDE_INVERT);
    gpio_set_inover(rx_pin_base + 1, GPIO_OVERRIDE_INVERT);

    // Set outputs as PIO outputs
    pio_sm_set_consecutive_pindirs(pio, 0, tx_pin_base, 2, true);

    //////
    
    master_pio = pio;
    master_offset = pio_add_program(pio, &isospi_master_program);
    master_config = isospi_master_program_get_default_config(master_offset);

    // Shift to right, autopull with threshold 8
    sm_config_set_out_shift(&master_config, false, true, 8);
    sm_config_set_set_pins(&master_config, tx_pin_base, 2);

    // Shift to right, autopush with threshold 32
    sm_config_set_in_shift(&master_config, false, true, 32);
    sm_config_set_in_pin_base(&master_config, rx_pin_base);
    sm_config_set_in_pin_count(&master_config, 2);

    //int sampling_pin = 22; // just after the TX pins
    //pio_gpio_init(pio, sampling_pin);
    //pio_sm_set_consecutive_pindirs(pio, 0, sampling_pin, 1, true);
    //sm_config_set_sideset_pins(&master_config, sampling_pin);

    //sm_config_set_clkdiv_int_frac8(&c, 1, 120);
    sm_config_set_clkdiv_int_frac8(&master_config, 1, 0);

    pio_sm_init(pio, 0, master_offset, &master_config);

    //////

    // setup CS program/config but don't load it

    /*
    cs_program_offset = pio_add_program(pio, &isospi_master_cs_program);
    cs_program_config = isospi_master_cs_program_get_default_config(cs_program_offset);

    // Shift to right, autopull with threshold 4
    sm_config_set_out_shift(&cs_program_config, false, true, 4);
    sm_config_set_out_pins(&cs_program_config, tx_pin_base, 2);
    sm_config_set_set_pins(&cs_program_config, tx_pin_base, 2);
    */


    cs_program_offset = pio_add_program(pio, &isospi_master_exec_program);
    cs_program_config = isospi_master_exec_program_get_default_config(cs_program_offset);

    // Shift to right, autopull with threshold 32
    sm_config_set_out_shift(&cs_program_config, false, true, 32);
    sm_config_set_out_pins(&cs_program_config, tx_pin_base, 2);
    sm_config_set_set_pins(&cs_program_config, tx_pin_base, 2);    

    //////

    //uint32_t offset = pio_add_program(pio, &isospi_master_wait_for_low_program);
    //pio_sm_config c2 = isospi_master_wait_for_low_program_get_default_config(offset);
    //sm_config_set_in_pin_base(&c2, 10);
    //sm_config_set_in_pin_count(&c2, 1);
    //pio_sm_init(pio, 1, offset, &c2);

    uint32_t offset = pio_add_program(pio, &isospi_master_wait_for_high_program);
    pio_sm_config c2 = isospi_master_wait_for_high_program_get_default_config(offset);
    sm_config_set_in_pin_base(&c2, rx_pin_base);
    sm_config_set_in_pin_count(&c2, 1);
    pio_sm_init(pio, 1, offset, &c2);

    //////

    pio_sm_config c3 = isospi_master_wait_for_high_program_get_default_config(offset);
    sm_config_set_in_pin_base(&c3, rx_pin_base + 1);
    sm_config_set_in_pin_count(&c3, 1);
    pio_sm_init(pio, 2, offset, &c3);

    //////

    offset = pio_add_program(pio, &isospi_master_wait_for_gap_program);
    pio_sm_config c4 = isospi_master_wait_for_gap_program_get_default_config(offset);
    sm_config_set_clkdiv_int_frac8(&c4, 1, 0);
    pio_sm_init(pio, 3, offset, &c4);

    //////

    pio_sm_set_enabled(pio, 0, true);
    pio_sm_set_enabled(pio, 1, true);
    pio_sm_set_enabled(pio, 2, true);
    pio_sm_set_enabled(pio, 3, true);
}

void isospi_master_cs(bool start) {
/*
  // Load the CS program into sm0 and start it
  pio_sm_init(master_pio, 0, cs_program_offset, &cs_program_config);
  pio_sm_set_enabled(master_pio, 0, true);

  // Send a CS
  pio_sm_put_blocking(master_pio, 0, (start ? 0b1011 : 0b1110) << 28);

  sleep_us(2);
*/

  pio_sm_init(master_pio, 0, cs_program_offset, &cs_program_config);

  // Queue up six instructions (there should be enough space in the FIFO)

  pio_sm_put_blocking(
    master_pio, 0, 
    ((pio_encode_set(pio_pins, (start ? TX_LOW : TX_HIGH)) | pio_encode_delay( CS_PULSE_LEN_A - 1 )) << 16) |
    (pio_encode_set(pio_pins, (start ? TX_LOW : TX_HIGH)) | pio_encode_delay( CS_PULSE_LEN_B - 1 ))
  );
  pio_sm_put_blocking(
    master_pio, 0, 
    ((pio_encode_set(pio_pins, (start ? TX_HIGH : TX_LOW)) | pio_encode_delay( CS_PULSE_LEN_A - 1 )) << 16) |
    (pio_encode_set(pio_pins, (start ? TX_HIGH : TX_LOW)) | pio_encode_delay( CS_PULSE_LEN_B - 1 ))
  );
  pio_sm_put_blocking(
    master_pio, 0, 
    ((pio_encode_set(pio_pins, TX_IDLE) | pio_encode_delay( 0 )) << 16) |
    (pio_encode_push(false, false))
  );

  // Start the program, which will consume the queued instructions

  pio_sm_set_enabled(master_pio, 0, true);

  // Wait for the push (indicates program complete)
  
  pio_sm_get_blocking(master_pio, 0);

  // Flush out the program to ensure it has finished
  // for(int i=0;i<4;i++) {
  //   pio_sm_put_blocking(master_pio, 0, (pio_encode_nop()<<16) | pio_encode_nop());
  // }

  // Load the master program back into sm0
  pio_sm_init(master_pio, 0, master_offset, &master_config);
  // Start it
  pio_sm_set_enabled(master_pio, 0, true);
}

%}
