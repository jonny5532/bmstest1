.pio_version 0

.program isosnoop
.side_set 1
.set 1

; the sampling points - multiplied by 6.7ns

.define SAMPLE_POS_1  5  ; 1 - 12 work  (100ns pulses)
.define SAMPLE_POS_2  20

; a delay after receiving to clear the final bit and wait for RX to settle

.define POST_RX_DELAY 15

.wrap_target

recv_wait:
    ; clear any pending irq
    irq clear 0 side 0

    ; wait for an interrupt from one of the detector state machines (or the timeout)
    wait 1 irq 0 side 0 [SAMPLE_POS_1 - 2]

recv_started:
    
    ; we started receiving - set the timer-disable GPIO high
    set pins, 1 side 0

    ; first sample (also store it in x for later)
    mov x, pins side 1 
    in x, 2 [SAMPLE_POS_2 - SAMPLE_POS_1 - 2] side 1

    ; second sample (also store it in y for later)
    mov y, pins side 0
    in y, 2 side 0

    jmp x-- received_something side 0
    jmp y-- received_something side 0

    ; both samples were idle, this was a gap, restart without starting timer
    jmp recv_wait side 0

received_something:
    ; we received data (this wasn't a gap)

    ; Extra delay for RX to settle (but not so long that we miss the next half of a CS)
    nop [POST_RX_DELAY] side 0
    ; might need more delay?

    ; Start the timer by clearing IRQ1
    irq clear 1 side 0

.wrap

.program isosnoop_wait_for_high

.wrap_target
    wait 1 pin 0
    irq set 0 [20]
    wait 0 pin 0 [12]
.wrap

.program isosnoop_wait_for_low

.wrap_target
    wait 0 pin 0
    irq set 0 [20]
    wait 1 pin 0 [12]
.wrap

.program isosnoop_wait_for_gap
.set 1

.wrap_target
begin:
    ; Wait to be woken up (set IRQ1 and wait for it to be cleared)
    irq wait 1

    ; Set the timer-disable GPIO low
    set pins, 0 [2] ; need at least 2 delay (plus the next instruction) for the pins to set

    ; How long to wait before triggering a receive (too short and we crash into
    ; a potential actual rx, ; too long and we crash into the one after)
    set x, 20
timer_loop:
    ; if timer-disable GPIO is high, cancel the timing and reset to the start
    jmp pin begin

    jmp x-- timer_loop ; if non-zero, continue looping

    ; trigger the receiver to receive a blank frame (which will record a gap)
    irq set 0
   
.wrap



% c-sdk {
// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin

void isosnoop_pio_setup(PIO pio, uint rx_pin_base, uint sampling_pin, uint rx_and_pin, uint timer_disable_pin) {
    // we don't need to init GPIOs as inputs

    gpio_init(rx_pin_base);
    gpio_set_dir(rx_pin_base, GPIO_IN);
    gpio_pull_up(rx_pin_base);

    gpio_init(rx_pin_base + 1);
    gpio_set_dir(rx_pin_base + 1, GPIO_IN);
    gpio_pull_up(rx_pin_base + 1);

    // invert both RX pins
    gpio_set_inover(rx_pin_base, GPIO_OVERRIDE_INVERT);
    gpio_set_inover(rx_pin_base + 1, GPIO_OVERRIDE_INVERT);

    uint offset = pio_add_program(pio, &isosnoop_program);
    pio_sm_config c = isosnoop_program_get_default_config(offset);

    // Shift to right, autopush with threshold 8
    sm_config_set_in_shift(&c, false, true, 8);
    sm_config_set_in_pin_base(&c, rx_pin_base);
    sm_config_set_in_pin_count(&c, 2); // rx_pin_base and rx_pin_base+1

    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // diagnostic output showing sampling points
    //pio_gpio_init(pio, sampling_pin);
    //pio_sm_set_consecutive_pindirs(pio, 0, sampling_pin, 1, true);
    //sm_config_set_sideset_pins(&c, sampling_pin);

    // configure (sampling_pin + 1) as set pin for timer disable flag
    //uint timer_disable_pin = sampling_pin + 1;
    pio_gpio_init(pio, timer_disable_pin);
    pio_sm_set_consecutive_pindirs(pio, 0, timer_disable_pin, 1, true);
    sm_config_set_set_pins(&c, timer_disable_pin, 1);


    // ST thing is 3.42857x slower
    //sm_config_set_clkdiv_int_frac8(&c, 3, 112);
    //sm_config_set_clkdiv_int_frac8(&c, 1, 120);
    sm_config_set_clkdiv_int_frac8(&c, 1, 0);

    pio_sm_init(pio, 0, offset, &c);

    ////

    offset = pio_add_program(pio, &isosnoop_wait_for_high_program);
    pio_sm_config c2 = isosnoop_wait_for_high_program_get_default_config(offset);
    sm_config_set_in_pin_base(&c2, rx_pin_base);
    sm_config_set_in_pin_count(&c2, 1);
    sm_config_set_clkdiv_int_frac8(&c2, 1, 0);

    //gpio_init(rx_and_pin);
    //gpio_set_dir(rx_and_pin, GPIO_IN);
    //gpio_pull_up(rx_and_pin);

    //gpio_init(15);
    //gpio_set_dir(15, GPIO_OUT);
    //gpio_set_drive_strength(15, GPIO_DRIVE_STRENGTH_12MA);
    //gpio_put(15, 1);

    //offset = pio_add_program(pio, &isosnoop_wait_for_low_program);
    //pio_sm_config c2 = isosnoop_wait_for_low_program_get_default_config(offset);
    //sm_config_set_in_pin_base(&c2, rx_and_pin);
    //sm_config_set_in_pin_count(&c2, 1);
    //sm_config_set_clkdiv_int_frac8(&c2, 1, 0);

    pio_sm_init(pio, 1, offset, &c2);

    ////

    pio_sm_config c3 = isosnoop_wait_for_high_program_get_default_config(offset);
    sm_config_set_in_pin_base(&c3, rx_pin_base + 1);
    sm_config_set_in_pin_count(&c3, 1);
    sm_config_set_clkdiv_int_frac8(&c3, 1, 0);

    //int sampling_pin2 = 26;
    //pio_gpio_init(pio, sampling_pin2);
    //pio_sm_set_consecutive_pindirs(pio, 2, sampling_pin2, 1, true);
    //sm_config_set_sideset_pins(&c3, sampling_pin2);

    pio_sm_init(pio, 2, offset, &c3);

    ////

    offset = pio_add_program(pio, &isosnoop_wait_for_gap_program);
    pio_sm_config c4 = isosnoop_wait_for_gap_program_get_default_config(offset);
    sm_config_set_clkdiv_int_frac8(&c4, 1, 0);

    // setup the edge flag pin for both in and set
    sm_config_set_set_pins(&c4, timer_disable_pin, 1);
    sm_config_set_jmp_pin(&c4, timer_disable_pin);

    pio_sm_init(pio, 3, offset, &c4);

    ////

    pio_sm_set_enabled(pio, 0, true);
    pio_sm_set_enabled(pio, 1, true);
    pio_sm_set_enabled(pio, 2, true);
    pio_sm_set_enabled(pio, 3, true);


}

%}
